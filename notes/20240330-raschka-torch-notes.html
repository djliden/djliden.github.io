<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PyTorch Review</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="/org-base.css"/>
<link rel="stylesheet" type="text/css" href="/orgstyle.css"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
<link rel="icon" href="favicon.ico" type="image/x-icon">
<link rel="me" href="https://emacs.ch/@dliden">
<link rel="alternate" type="application/rss+xml" title="Daniel Liden's Blog" href="/rss.xml">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="/dark-mode.js" defer></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="preamble" class="status">
<hr class="topnav-rule">
<header class="site-header">
  <a href="/index.html" class="site-header__brand">
    <h2>Daniel Liden</h2>
  </a>
  <nav class="topnav-links" aria-label="Primary">
    <a href="/archive.html">Blog</a>
    <span class="topnav-divider" aria-hidden="true">/</span>
    <a href="/about.html">About Me</a>
    <span class="topnav-divider" aria-hidden="true">/</span>
    <a href="/photos.html">Photos</a>
    <span class="topnav-divider" aria-hidden="true">/</span>
    <a href="/notebooks/">Notebooks</a>
    <span class="topnav-divider" aria-hidden="true">/</span>
    <a href="/notes.html">Notes</a>
    <span class="topnav-divider" aria-hidden="true">/</span>
    <a class="topnav-icon" href="/rss.xml" aria-label="RSS feed">
      <svg class="rss-icon" viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
        <path d="M5 4h1a14 14 0 0 1 14 14v1"/>
        <path d="M5 11h1a7 7 0 0 1 7 7v1"/>
        <circle cx="6" cy="18" r="2"/>
      </svg>
    </a>
    <span class="topnav-divider" aria-hidden="true">/</span>
    <button id="theme-toggle" class="nav-theme-toggle topnav-icon" type="button" aria-label="Switch to dark mode" aria-pressed="false">
      <svg class="theme-icon" viewBox="0 0 24 24" aria-hidden="true" fill="currentColor">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79Z"/>
      </svg>
    </button>
  </nav>
</header>
<hr class="topnav-rule">
</div>
<div id="content" class="content">
<header>
<h1 class="title">PyTorch Review</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga5a11d2">A.1 PyTorch</a></li>
<li><a href="#orgc1699d0">A.2 Understanding tensors</a>
<ul>
<li><a href="#orgb0bc8ee">Creating tensors</a></li>
<li><a href="#org064d1af">Tensor data types</a></li>
<li><a href="#org460589b">Common tensor operations</a></li>
</ul>
</li>
<li><a href="#org970cf37">A.3 Models as Computational Graphs</a></li>
<li><a href="#orge0faaad">A.4 Automatic Differentiation</a></li>
<li><a href="#orged4dbdc">A.5 Implementing multilayer neural networks</a></li>
<li><a href="#org49fd392">A.6 Setting up efficient data loaders</a></li>
<li><a href="#org1774662">A.7 A typical training loop</a></li>
<li><a href="#orge9a4fd2">A.8 Saving and Loading Models</a></li>
<li><a href="#org65e9781">A.9 Optimizing training performance with GPUs</a>
<ul>
<li><a href="#orgb42ad29">Computations on GPUs</a></li>
<li><a href="#org5db4616">Single-GPU Training</a></li>
<li><a href="#org8121414">Multi-GPU Training</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<div class="preview" id="org7a6b6e0">
<p>
This is a quick run through the appendix on PyTorch from Sebastian Raschka's <a href="https://www.manning.com/books/build-a-large-language-model-from-scratch">Build a Large Language Model (From Scratch)</a> book, currently available via Manning's MEAP. I haven't spent an enormous amount of time with PyTorch in the last year or so, so it seemed worth the effort to work through it.
</p>

</div>

<div id="outline-container-orga5a11d2" class="outline-2">
<h2 id="orga5a11d2">A.1 PyTorch</h2>
<div class="outline-text-2" id="text-orga5a11d2">
<p>
There are three broad components to PyTorch:
</p>
<ul class="org-ul">
<li>A tensor library extending array-oriented programming from NumPy with additional features for accelerated computation on GPUs.</li>
<li>An automatic differentiation engine (autograd), which ehables automatic computation of gradients for tensor operations for backpropagation/model optimization.</li>
<li>A deep learning library, offering modular, flexible, and extensible building blocks for designing and training deep learning models.</li>
</ul>

<p>
Let's make sure we have it installed correctly&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> torch

torch.__version__
</pre>
</div>

<pre class="example">
2.2.2
</pre>


<p>
Let's make sure we can use <code>mps</code> (on mac).
</p>

<div class="org-src-container">
<pre class="src src-python">torch.backends.mps.is_available()
</pre>
</div>

<pre class="example">
True
</pre>


<p>
Great.
</p>
</div>
</div>
<div id="outline-container-orgc1699d0" class="outline-2">
<h2 id="orgc1699d0">A.2 Understanding tensors</h2>
<div class="outline-text-2" id="text-orgc1699d0">
<p>
Tensors generalize vectors and matrices to arbitrary dimensions. PyTorch tensors are similar to NumPy arrays but have have several additional features:
</p>
<ul class="org-ul">
<li>an automatic differentiation engine</li>
<li>gpu computation</li>
</ul>
<p>
Still, it has a numpy-like API.
</p>
</div>
<div id="outline-container-orgb0bc8ee" class="outline-3">
<h3 id="orgb0bc8ee">Creating tensors</h3>
<div class="outline-text-3" id="text-orgb0bc8ee">
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">0d tensor (scalar)
</span><span class="org-builtin">print</span>(torch.tensor(1))

<span class="org-comment-delimiter"># </span><span class="org-comment">1d tensor (vector)
</span><span class="org-builtin">print</span>(torch.tensor([1, 2, 3]))

<span class="org-comment-delimiter"># </span><span class="org-comment">2d tensor
</span><span class="org-builtin">print</span>(torch.tensor([[1, 2], [3, 4]]))

<span class="org-comment-delimiter"># </span><span class="org-comment">3d tensor
</span><span class="org-builtin">print</span>(torch.tensor([[[1, 2], [3,4]], [[5,6], [7,8]]]))
</pre>
</div>

<pre class="example">
tensor(1)
tensor([1, 2, 3])
tensor([[1, 2],
        [3, 4]])
tensor([[[1, 2],
         [3, 4]],

        [[5, 6],
         [7, 8]]])
</pre>
</div>
</div>
<div id="outline-container-org064d1af" class="outline-3">
<h3 id="org064d1af">Tensor data types</h3>
<div class="outline-text-3" id="text-org064d1af">
<p>
These are important to pay attention to! So let's pay attention to them. The default (from above) is the 64-bit integer.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">tensor1d</span> <span class="org-operator">=</span> torch.tensor([1,2,3])
<span class="org-builtin">print</span>(tensor1d.dtype)
</pre>
</div>

<pre class="example">
torch.int64
</pre>


<p>
For floats, PyTorch uses 32-bit precision by default.
</p>


<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">floatvec</span> <span class="org-operator">=</span> torch.tensor([1., 2., 3.])
<span class="org-builtin">print</span>(floatvec.dtype)
</pre>
</div>

<pre class="example">
torch.float32
</pre>


<p>
Why this default?
</p>
<ul class="org-ul">
<li>GPU architectures are optimized for 32-bit computations</li>
<li>32-bit precision is sufficient for most deep learning tasks but uses less memory and computational resources than 64-bit.</li>
</ul>

<p>
it is easy to change <code>dtype</code> (and precision) with a tensor's <code>.to</code> method.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(torch.tensor([1,2,3]).to(torch.float32).dtype)
</pre>
</div>

<pre class="example">
torch.float32
</pre>
</div>
</div>
<div id="outline-container-org460589b" class="outline-3">
<h3 id="org460589b">Common tensor operations</h3>
<div class="outline-text-3" id="text-org460589b">
<ul class="org-ul">
<li>brief survey of the most common tensor operations prior to getting into the computational graphs concept.</li>
</ul>


<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">tensor2d</span> <span class="org-operator">=</span> torch.tensor([[1, 2, 3], [4, 5, 6]])
</pre>
</div>

<p>
Reshape:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(tensor2d.reshape(3, 2))
</pre>
</div>

<pre class="example">
tensor([[1, 2],
        [3, 4],
        [5, 6]])
</pre>


<p>
It is more common to use <code>view</code> than <code>reshape</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(tensor2d.view(3, 2))
</pre>
</div>

<pre class="example">
tensor([[1, 2],
        [3, 4],
        [5, 6]])
</pre>


<p>
Transpose
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(tensor2d.T)
</pre>
</div>

<pre class="example">
tensor([[1, 4],
        [2, 5],
        [3, 6]])
</pre>



<p>
Matrix multiplication is usually handled with <code>matmul</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(tensor2d.matmul(tensor2d.T))
</pre>
</div>

<pre class="example">
tensor([[14, 32],
        [32, 77]])
</pre>


<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(tensor2d @ tensor2d.T)
</pre>
</div>

<pre class="example">
tensor([[14, 32],
        [32, 77]])
</pre>
</div>
</div>
</div>
<div id="outline-container-org970cf37" class="outline-2">
<h2 id="org970cf37">A.3 Models as Computational Graphs</h2>
<div class="outline-text-2" id="text-org970cf37">
<p>
The previous section covered PyTorch's tensor library. This section gets into its automatic differentiation engine (autograd). Autograd provides functions for automatically computing gradients in dynamic computational graphs.
</p>

<p>
So what's a computational graph? It lays out the sequence of calculations needed to compute the gradients for backprop. We'll go through an example showing the forward pass of a logstic regression classifier.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> torch.nn.functional <span class="org-keyword">as</span> F

<span class="org-variable-name">y</span> <span class="org-operator">=</span> torch.tensor([1.0])
<span class="org-variable-name">x1</span> <span class="org-operator">=</span> torch.tensor([1.1])
<span class="org-variable-name">w1</span> <span class="org-operator">=</span> torch.tensor([2.2])
<span class="org-variable-name">b</span> <span class="org-operator">=</span> torch.tensor([0.0])

<span class="org-variable-name">z</span> <span class="org-operator">=</span> x1 <span class="org-operator">*</span> w1 <span class="org-operator">+</span> b
<span class="org-variable-name">a</span> <span class="org-operator">=</span> torch.sigmoid(z)

<span class="org-variable-name">loss</span> <span class="org-operator">=</span> F.binary_cross_entropy(a,y)
</pre>
</div>

<p>
This results in a computational graph which PyTorch builds in the background.
</p>

<p>
Input and weight -&gt; (u = w<sub>1</sub> * x<sub>1</sub>) -&gt; +b -&gt; (z = u + b) -&gt; (a = &sigma;(z)) -&gt; loss = L(a,y) &lt;- y
</p>
</div>
</div>
<div id="outline-container-orge0faaad" class="outline-2">
<h2 id="orge0faaad">A.4 Automatic Differentiation</h2>
<div class="outline-text-2" id="text-orge0faaad">
<p>
PyTorch will automatically build such a graph if one of its terminal nodes has the <code>requires_grad</code> attribute set to True. This enables us to train neural nets via backpropagation. Working backward from the above:
</p>

\begin{align*}
\frac{\partial L}{\partial w_1} &= \frac{\partial u}{\partial w_1} \times \frac{\partial z}{\partial u} \times \frac{\partial a}{\partial z} \times \frac{\partial L}{\partial a} \\
\frac{\partial L}{\partial b} &= \frac{\partial z}{\partial b} \times \frac{\partial a}{\partial z} \times \frac{\partial L}{\partial a}
\end{align*}

<p>
Basically&#x2013;apply the chain rule right to left.
</p>

<p>
Quick reminder of some definitions:
</p>
<ul class="org-ul">
<li>a partial derivative measures the rate at which a function changes w/r/t one of its variables</li>
<li>a gradient is a vector of all the partial derivatives of a multivariate function</li>
</ul>

<p>
So what exactly does this have to do with torch as an autograd engine? PyTorch tracks every operation performed on tensors and can, therefore, construct a computational graph in the background. Then it cal cann on the <code>grad</code> function to compute the gradient of the loss w/r/t the model parameter as follows:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> torch.nn.functional <span class="org-keyword">as</span> F
<span class="org-keyword">from</span> torch.autograd <span class="org-keyword">import</span> grad

<span class="org-variable-name">y</span> <span class="org-operator">=</span> torch.tensor([1.0])
<span class="org-variable-name">x1</span> <span class="org-operator">=</span> torch.tensor([1.1])
<span class="org-variable-name">w1</span> <span class="org-operator">=</span> torch.tensor([2.2], requires_grad<span class="org-operator">=</span><span class="org-constant">True</span>)
<span class="org-variable-name">b</span> <span class="org-operator">=</span> torch.tensor([0.0], requires_grad<span class="org-operator">=</span><span class="org-constant">True</span>)

<span class="org-variable-name">z</span> <span class="org-operator">=</span> x1 <span class="org-operator">*</span> w1 <span class="org-operator">+</span> b
<span class="org-variable-name">a</span> <span class="org-operator">=</span> torch.sigmoid(z)

<span class="org-variable-name">loss</span> <span class="org-operator">=</span> F.binary_cross_entropy(a, y)
<span class="org-variable-name">grad_L_w1</span> <span class="org-operator">=</span> grad(loss, w1, retain_graph<span class="org-operator">=</span><span class="org-constant">True</span>) <span class="org-comment-delimiter">#</span><span class="org-comment">A
</span><span class="org-variable-name">grad_L_b</span> <span class="org-operator">=</span> grad(loss, b, retain_graph<span class="org-operator">=</span><span class="org-constant">True</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(grad_L_w1)
<span class="org-builtin">print</span>(grad_L_b)
</pre>
</div>

<pre class="example">
(tensor([-0.0898]),)
(tensor([-0.0817]),)
</pre>


<p>
We seldom manually call the grad function. We usually call <code>.backward</code> on the loss, which computes the gradients of all the leaf nodes in the graph, which will be stored via the <code>.grad</code> attributes of the tensors.
</p>


<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(loss.backward())
<span class="org-builtin">print</span>(w1.grad)
<span class="org-builtin">print</span>(b.grad)
</pre>
</div>

<pre class="example">
None
tensor([-0.0898])
tensor([-0.0817])
</pre>
</div>
</div>
<div id="outline-container-orged4dbdc" class="outline-2">
<h2 id="orged4dbdc">A.5 Implementing multilayer neural networks</h2>
<div class="outline-text-2" id="text-orged4dbdc">
<p>
Now we get to the third major component of Pytorch: its library for implementing deep neural networks.
</p>

<p>
We will focus on a fully-connected MLP. To implement an NN in PyTorch, we:
</p>
<ul class="org-ul">
<li>subclass the <code>torch.nn.Module</code> class to define a custom architecture</li>
<li>define layers within the <code>__init__</code> constructor of the module subclass, specifying how they interact in the forward method.</li>
<li>defined the forward method, which describes how data passes through the network and relates as a computational graph.</li>
</ul>

<p>
We generally do not need to implement the <code>backward</code> method ourselves.
</p>

<p>
Here is code illustrating a basic NN with two hidden layers.
</p>


<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">NeuralNetwork</span>(torch.nn.Module):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, num_inputs, num_outputs):
        <span class="org-builtin">super</span>().__init__()

        <span class="org-keyword">self</span>.<span class="org-variable-name">layers</span> <span class="org-operator">=</span> torch.nn.Sequential(
            <span class="org-comment-delimiter"># </span><span class="org-comment">1st hidden layer
</span>            torch.nn.Linear(num_inputs, 30),
            torch.nn.ReLU(),
            <span class="org-comment-delimiter"># </span><span class="org-comment">2nd hidden layer
</span>            torch.nn.Linear(30, 20),
            torch.nn.ReLU(),
            <span class="org-comment-delimiter"># </span><span class="org-comment">output layer
</span>            torch.nn.Linear(20, num_outputs),
        )

    <span class="org-keyword">def</span> <span class="org-function-name">forward</span>(<span class="org-keyword">self</span>, x):
        <span class="org-variable-name">logits</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.layers(x)
        <span class="org-keyword">return</span> logits
</pre>
</div>

<p>
We can instantiate this with 50 inputs and 3 outputs.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">model</span> <span class="org-operator">=</span> NeuralNetwork(50, 3)
<span class="org-builtin">print</span>(model)
</pre>
</div>

<pre class="example">
NeuralNetwork(
  (layers): Sequential(
    (0): Linear(in_features=50, out_features=30, bias=True)
    (1): ReLU()
    (2): Linear(in_features=30, out_features=20, bias=True)
    (3): ReLU()
    (4): Linear(in_features=20, out_features=3, bias=True)
  )
)
</pre>


<p>
We can count the total number of trainable parameters as follows:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">num_params</span> <span class="org-operator">=</span> <span class="org-builtin">sum</span>(p.numel() <span class="org-keyword">for</span> p <span class="org-keyword">in</span> model.parameters() <span class="org-keyword">if</span> p.requires_grad)
<span class="org-builtin">print</span>(<span class="org-string">"Total number of trainable model parameters:"</span>, num_params)
</pre>
</div>

<pre class="example">
Total number of trainable model parameters: 2213
</pre>


<p>
A parameter is <i>trainable</i> if its <code>requires_grad</code> attribute is <code>True</code>. We can investigate specific layers. Let's look at the first linear layer.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(model.layers[0].weight)
</pre>
</div>

<pre class="example">
Parameter containing:
tensor([[-0.0844,  0.0863,  0.1168,  ...,  0.0203, -0.0814, -0.0504],
        [ 0.0288,  0.0004, -0.1411,  ..., -0.0322, -0.1085,  0.0682],
        [-0.1075, -0.0173, -0.0476,  ..., -0.0684, -0.0522, -0.1316],
        ...,
        [ 0.1129, -0.0639, -0.0662,  ...,  0.1284, -0.0707,  0.1090],
        [ 0.0790, -0.1206, -0.1156,  ...,  0.1393, -0.0233,  0.1035],
        [-0.0078, -0.0789,  0.0931,  ...,  0.0220, -0.0572,  0.1112]],
       requires_grad=True)
</pre>


<p>
This is truncated, so let's look at the shape instead to make sure it matches with our expectations.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> rich <span class="org-keyword">import</span> <span class="org-builtin">print</span>

<span class="org-builtin">print</span>(model.layers[0].weight.shape)
</pre>
</div>

<pre class="example">
torch.Size([30, 50])
</pre>


<p>
We can call on the model like this:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">X</span> <span class="org-operator">=</span> torch.rand((1,50))
<span class="org-variable-name">out</span> <span class="org-operator">=</span> model(X)
<span class="org-builtin">print</span>(out)
</pre>
</div>

<pre class="example">
tensor([[ 0.0623, -0.0063, -0.1485]], grad_fn=&lt;AddmmBackward0&gt;)
</pre>


<p>
We generated a single random example (50 dimensions) and passed it to the model. This was the <i>forward pass</i>. The forward pass simply means calculating the output tensors from the input tensors.
</p>

<p>
As we can see from the <code>grad_fn</code>, this forward pass computes a computational graph for backprop. This can be wasteful and unnecessary if we're just interested in inference. We use the <code>torch.no_grad</code> context manager to get around this.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> torch.no_grad():
    <span class="org-variable-name">out</span> <span class="org-operator">=</span> model(X)
<span class="org-builtin">print</span>(out)
</pre>
</div>

<pre class="example">
tensor([[ 0.0623, -0.0063, -0.1485]])
</pre>


<p>
And this approach just computes the output tensors.
</p>

<p>
Usually in PyTorch we don't pass the final layer to a nonlinear activation function, because the loss function usually combines softmax with negativel og-likelihood loss in a single class. We have to call softmax explicitly if we want class-membership probabilities.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">with</span> torch.no_grad():
    <span class="org-variable-name">out</span> <span class="org-operator">=</span> torch.softmax(model(X), dim<span class="org-operator">=</span>1)
<span class="org-builtin">print</span>(out)
</pre>
</div>

<pre class="example">
tensor([[0.3645, 0.3403, 0.2952]])
</pre>
</div>
</div>

<div id="outline-container-org49fd392" class="outline-2">
<h2 id="org49fd392">A.6 Setting up efficient data loaders</h2>
<div class="outline-text-2" id="text-org49fd392">
<p>
A <code>DataSet</code> is a class that defines how individual records are loaded. A <code>DataLoader</code> class handles dataset shuffling and assembling data records into batches.
</p>

<p>
This example shows a dataset of five training examples with two features each, along with a tensor of class labels. We also have a test dataset of two entries.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">X_train</span> <span class="org-operator">=</span> torch.tensor(
    [[<span class="org-operator">-</span>1.2, 3.1], [<span class="org-operator">-</span>0.9, 2.9], [<span class="org-operator">-</span>0.5, 2.6], [2.3, <span class="org-operator">-</span>1.1], [2.7, <span class="org-operator">-</span>1.5]]
)
<span class="org-variable-name">y_train</span> <span class="org-operator">=</span> torch.tensor([0, 0, 0, 1, 1])
<span class="org-variable-name">X_test</span> <span class="org-operator">=</span> torch.tensor(
    [
        [<span class="org-operator">-</span>0.8, 2.8],
        [2.6, <span class="org-operator">-</span>1.6],
    ]
)
<span class="org-variable-name">y_test</span> <span class="org-operator">=</span> torch.tensor([0, 1])
</pre>
</div>

<p>
Let's first make these into a <code>DataSet</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> torch.utils.data <span class="org-keyword">import</span> Dataset

<span class="org-keyword">class</span> <span class="org-type">ToyDataset</span>(Dataset):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, X, y):
        <span class="org-keyword">self</span>.<span class="org-variable-name">features</span> <span class="org-operator">=</span> X
        <span class="org-keyword">self</span>.<span class="org-variable-name">labels</span> <span class="org-operator">=</span> y

    <span class="org-keyword">def</span> <span class="org-function-name">__getitem__</span>(<span class="org-keyword">self</span>, index):
        <span class="org-variable-name">one_x</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.features[index]
        <span class="org-variable-name">one_y</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.labels[index]
        <span class="org-keyword">return</span> one_x, one_y

    <span class="org-keyword">def</span> <span class="org-function-name">__len__</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.labels.shape[0]

<span class="org-variable-name">train_ds</span> <span class="org-operator">=</span> ToyDataset(X_train, y_train)
<span class="org-variable-name">test_ds</span> <span class="org-operator">=</span> ToyDataset(X_test, y_test)
</pre>
</div>


<p>
Note the three main components of the above Dataset definition:
</p>
<ol class="org-ol">
<li><code>__init__</code>, to set up attributes we can access in the other methods. This might be file paths, file objects, database connectors, etc. Here we just use X and y, which we point toward the correct tensor objects in memory.</li>
<li><code>__getitem__</code> is for defining instructions for retrieving exactly one record via <code>index</code>.</li>
<li><p>
<code>__len__</code> is for retrieving the length of the dataset.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(<span class="org-builtin">len</span>(train_ds))
</pre>
</div>

<pre class="example">
5
</pre></li>
</ol>

<p>
Now we can use the <code>DataLoader</code> class to define how to sample from the Dataset we defined.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> torch.utils.data <span class="org-keyword">import</span> DataLoader

torch.manual_seed(123)

<span class="org-variable-name">train_loader</span> <span class="org-operator">=</span> DataLoader(
    dataset<span class="org-operator">=</span>train_ds,
    batch_size<span class="org-operator">=</span>2,
    shuffle<span class="org-operator">=</span><span class="org-constant">True</span>,
    num_workers<span class="org-operator">=</span>0
    )

<span class="org-variable-name">test_loader</span> <span class="org-operator">=</span> DataLoader(
    dataset<span class="org-operator">=</span>test_ds,
    batch_size<span class="org-operator">=</span>2,
    shuffle<span class="org-operator">=</span><span class="org-constant">False</span>,
    num_workers<span class="org-operator">=</span>0
    )
</pre>
</div>

<p>
Now we can iterate over the <code>train_loader</code> as follows:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">for</span> idx, (x, y) <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(train_loader):
    <span class="org-builtin">print</span>(f<span class="org-string">"Batch </span>{idx<span class="org-operator">+</span>1}<span class="org-string">:"</span>, x, y)
</pre>
</div>

<pre class="example">
Batch 1: tensor([[ 2.3000, -1.1000],
        [-0.9000,  2.9000]]) tensor([1, 0])

Batch 2: tensor([[-1.2000,  3.1000],
        [-0.5000,  2.6000]]) tensor([0, 0])

Batch 3: tensor([[ 2.7000, -1.5000]]) tensor([1])
</pre>


<p>
Note that we can set <code>drop_last=True</code> to drop the last uneven batch, as significantly uneven batch sizes can harm convergence.
</p>

<p>
The <code>num_workers</code> argument relates to parallelizing data loading/processing. 0 indicates that it will all be done in the main process, not in separate worker processes. This can slow things down a lot.
</p>
</div>
</div>

<div id="outline-container-org1774662" class="outline-2">
<h2 id="org1774662">A.7 A typical training loop</h2>
<div class="outline-text-2" id="text-org1774662">
<p>
In this section, we combine many of the techniques from above to show a complete training loop.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> torch
<span class="org-keyword">import</span> torch.nn.functional <span class="org-keyword">as</span> F
 
 
torch.manual_seed(123)
<span class="org-variable-name">model</span> <span class="org-operator">=</span> NeuralNetwork(num_inputs<span class="org-operator">=</span>2, num_outputs<span class="org-operator">=</span>2)
<span class="org-variable-name">optimizer</span> <span class="org-operator">=</span> torch.optim.SGD(model.parameters(), lr<span class="org-operator">=</span>0.5)
 
<span class="org-variable-name">num_epochs</span> <span class="org-operator">=</span> 3
 
<span class="org-keyword">for</span> epoch <span class="org-keyword">in</span> <span class="org-builtin">range</span>(num_epochs): 
    
    model.train()
    <span class="org-keyword">for</span> batch_idx, (features, labels) <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(train_loader):
 
        <span class="org-variable-name">logits</span> <span class="org-operator">=</span> model(features)
        
        <span class="org-variable-name">loss</span> <span class="org-operator">=</span> F.cross_entropy(logits, labels)
        
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
    
        <span class="org-comment-delimiter">### </span><span class="org-comment">LOGGING
</span>        <span class="org-builtin">print</span>(f<span class="org-string">"Epoch: </span>{epoch<span class="org-operator">+</span>1:03d}<span class="org-string">/</span>{num_epochs:03d}<span class="org-string">"</span>
              f<span class="org-string">" | Batch </span>{batch_idx:03d}<span class="org-string">/</span>{<span class="org-builtin">len</span>(train_loader):03d}<span class="org-string">"</span>
              f<span class="org-string">" | Train Loss: </span>{loss:.2f}<span class="org-string">"</span>)
 
    model.<span class="org-builtin">eval</span>()
    <span class="org-comment-delimiter"># </span><span class="org-comment">Optional model evaluation</span>
</pre>
</div>

<pre class="example">
Epoch: 001/003 | Batch 000/003 | Train Loss: 0.75
Epoch: 001/003 | Batch 001/003 | Train Loss: 0.65
Epoch: 001/003 | Batch 002/003 | Train Loss: 0.42
Epoch: 002/003 | Batch 000/003 | Train Loss: 0.05
Epoch: 002/003 | Batch 001/003 | Train Loss: 0.13
Epoch: 002/003 | Batch 002/003 | Train Loss: 0.00
Epoch: 003/003 | Batch 000/003 | Train Loss: 0.01
Epoch: 003/003 | Batch 001/003 | Train Loss: 0.00
Epoch: 003/003 | Batch 002/003 | Train Loss: 0.02
</pre>



<p>
Note the use of <code>model.train</code> and <code>model.eval</code>. These set the model into training and evaluation mode, respectively. Some components behave differently during training or inference, such as ddropout or batch normalization. We don't have these or anything like them, so this is redundant in our code, but still good practice.
</p>

<p>
We pass the logits directly to <code>cross_entropy</code> to compute the loss and call <code>loss.backward()</code> to compute gradients. <code>optimizer.step</code> uses the gradients to update the model parameters.
</p>

<p>
It is important that we include an <code>optimizer.zero_grad</code> call in each update to reset the gradients and ensure they do not accumulate.
</p>

<p>
Now we can make predictions with the model.
</p>

<div class="org-src-container">
<pre class="src src-python">model.<span class="org-builtin">eval</span>()
<span class="org-keyword">with</span> torch.no_grad():
    <span class="org-variable-name">outputs</span> <span class="org-operator">=</span> model(X_train)
<span class="org-builtin">print</span>(outputs)
</pre>
</div>

<pre class="example">
tensor([[ 2.9320, -4.2563],
        [ 2.6045, -3.8389],
        [ 2.1484, -3.2514],
        [-2.1461,  2.1496],
        [-2.5004,  2.5210]])
</pre>


<p>
If we want the class membership, we can obtain it with:
</p>

<div class="org-src-container">
<pre class="src src-python">torch.set_printoptions(sci_mode<span class="org-operator">=</span><span class="org-constant">False</span>)
<span class="org-variable-name">probas</span> <span class="org-operator">=</span> torch.softmax(outputs, dim<span class="org-operator">=</span>1)
<span class="org-builtin">print</span>(probas)
</pre>
</div>

<pre class="example">
tensor([[    0.9992,     0.0008],
        [    0.9984,     0.0016],
        [    0.9955,     0.0045],
        [    0.0134,     0.9866],
        [    0.0066,     0.9934]])
</pre>


<p>
There are two classes, so the above represents the probabilities of belonging to class 1 or class 2. The first three have high probability of class 1; the last two of class 2.
</p>

<p>
We can convery into class labels as follows:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">predictions</span> <span class="org-operator">=</span> torch.argmax(probas, dim<span class="org-operator">=</span>1)
<span class="org-builtin">print</span>(predictions)
</pre>
</div>

<pre class="example">
tensor([0, 0, 0, 1, 1])
</pre>


<p>
We don't need to compute softmax probabilities to accomplish this.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(torch.argmax(outputs, dim<span class="org-operator">=</span>1))
</pre>
</div>

<pre class="example">
tensor([0, 0, 0, 1, 1])
</pre>


<p>
Is it correct?
</p>

<div class="org-src-container">
<pre class="src src-python">predictions <span class="org-operator">==</span> y_train
</pre>
</div>

<pre class="example">
tensor([True, True, True, True, True])
</pre>


<p>
and to get the proportion correct:
</p>
<div class="org-src-container">
<pre class="src src-python">torch.<span class="org-builtin">sum</span>(predictions <span class="org-operator">==</span> y_train) <span class="org-operator">/</span> <span class="org-builtin">len</span>(y_train)
</pre>
</div>

<pre class="example">
tensor(1.)
</pre>
</div>
</div>


<div id="outline-container-orge9a4fd2" class="outline-2">
<h2 id="orge9a4fd2">A.8 Saving and Loading Models</h2>
<div class="outline-text-2" id="text-orge9a4fd2">
<p>
We can save a model as follows:
</p>

<div class="org-src-container">
<pre class="src src-python">torch.save(model.state_dict(), <span class="org-string">"model.pth"</span>)
</pre>
</div>

<p>
<code>.pt</code> and <code>.pth</code> are the most common extensions, by convention, but we can use whatever we want.
</p>

<p>
We restore a model with:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">model</span> <span class="org-operator">=</span> NeuralNetwork(2,2)
model.load_state_dict(torch.load(<span class="org-string">"model.pth"</span>))
</pre>
</div>

<p>
It is necessary to have an instance of the model in memory in order to load the model weights.
</p>
</div>
</div>
<div id="outline-container-org65e9781" class="outline-2">
<h2 id="org65e9781">A.9 Optimizing training performance with GPUs</h2>
<div class="outline-text-2" id="text-org65e9781">
</div>

<div id="outline-container-orgb42ad29" class="outline-3">
<h3 id="orgb42ad29">Computations on GPUs</h3>
<div class="outline-text-3" id="text-orgb42ad29">
<ul class="org-ul">
<li>Modifying training runs to use GPU in PyTorch is easy</li>
<li>In PyTorch, a <code>device</code> is where computations occur and data resides. A pytorch tensor lives on a device and its operations are executed on that device.</li>
</ul>

<p>
Because I am running this locally, I am going to try to follow these examples with mps.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(<span class="org-string">"MPS is available."</span> <span class="org-keyword">if</span> torch.backends.mps.is_available() <span class="org-keyword">else</span> <span class="org-string">"MPS is not available."</span>)
</pre>
</div>

<pre class="example">
MPS is available.
</pre>


<p>
By default, operations are done on CPU.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">tensor_1</span> <span class="org-operator">=</span> torch.tensor([1., 2., 3.])
<span class="org-variable-name">tensor_2</span> <span class="org-operator">=</span> torch.tensor([4., 5., 6.])
tensor_1 <span class="org-operator">+</span> tensor_2
</pre>
</div>

<pre class="example">
tensor([5., 7., 9.])
</pre>


<p>
Now we can transfer the tensors to GPU and perform the addition there.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">tensor_1</span> <span class="org-operator">=</span> tensor_1.to(<span class="org-string">"mps"</span>)
<span class="org-variable-name">tensor_2</span> <span class="org-operator">=</span> tensor_2.to(<span class="org-string">"mps"</span>)
tensor_1 <span class="org-operator">+</span> tensor_2
</pre>
</div>

<pre class="example">
tensor([5., 7., 9.], device='mps:0')
</pre>


<p>
All tensors have to be on the same device or the computation will fail.
</p>


<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">tensor_1</span> <span class="org-operator">=</span> tensor_1.to(<span class="org-string">"mps"</span>)
<span class="org-variable-name">tensor_2</span> <span class="org-operator">=</span> tensor_2.to(<span class="org-string">"cpu"</span>)
tensor_1 <span class="org-operator">+</span> tensor_2
</pre>
</div>

<pre class="example">
Traceback (most recent call last):
  File "&lt;string&gt;", line 17, in __PYTHON_EL_eval
  File "&lt;string&gt;", line 3, in &lt;module&gt;
  File "/var/folders/vq/mfrl6bsd37jglvmz0vyxf3000000gn/T/babel-YaG8HR/python-l9RkUi", line 3, in &lt;module&gt;
    tensor_1 + tensor_2
    ~~~~~~~~~^~~~~~~~~~
RuntimeError: Expected all tensors to be on the same device, but found at least two devices, mps:0 and cpu!
</pre>
</div>
</div>
<div id="outline-container-org5db4616" class="outline-3">
<h3 id="org5db4616">Single-GPU Training</h3>
<div class="outline-text-3" id="text-org5db4616">
<p>
All we need to do to train on a single GPU is:
</p>
<ul class="org-ul">
<li>set <code>device = torch.device("cuda")</code></li>
<li>set <code>model = model.to(device)</code></li>
<li>set <code>features, labels = features.to(device), labels.to(device)</code></li>
</ul>

<p>
This is usually considered the best practice:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">device</span> <span class="org-operator">=</span> torch.device(<span class="org-string">"cuda"</span> <span class="org-keyword">if</span> torch.cuda.is_available() <span class="org-keyword">else</span> <span class="org-string">"cpu"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-org8121414" class="outline-3">
<h3 id="org8121414">Multi-GPU Training</h3>
<div class="outline-text-3" id="text-org8121414">
<p>
This section introduces the idea of <i>distributed training</i>.
</p>

<p>
The most basic approach uses PyTorch's <code>DistributedDataParallel</code> strategy. DDP splits inputs across available devices and processes the subsets simultaneously. How does this work?
</p>
<ul class="org-ul">
<li>PyTorch launches a separate process on each GPU</li>
<li>Each process keeps a copy of the model</li>
<li>The copies are synchronized during training. The computed gradients are averaged and synchronized during training to update the model copies.</li>
</ul>

<p>
DDP offers enhanced training speed.
</p>

<div class="notice" id="orge816769">
<p>
DDP does not function properly in interactive environments like Jupyter notebooks. DDP code must be run as a script, not within a notebook interface.
</p>

</div>


<p>
First we load the utilities:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> torch.multiprocessing <span class="org-keyword">as</span> mp
<span class="org-keyword">from</span> torch.utils.data.distributed <span class="org-keyword">import</span> DistributedSampler
<span class="org-keyword">from</span> torch.nn.parallel <span class="org-keyword">import</span> DistributedDataParallel <span class="org-keyword">as</span> DDP
<span class="org-keyword">from</span> torch.distributed <span class="org-keyword">import</span> init_process_group, destroy_process_group
</pre>
</div>


<ul class="org-ul">
<li><code>multiprocessing</code> includes various functions for spawning multiple processes and applying functions in parallel.</li>
<li><code>DistributedSampler</code> is for dividing the training data among processes.</li>
<li>The init/destroy process group functions are for starting and ending the distributed training modules.</li>
</ul>


<p>
Here is an example script for distributed training.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">ddp_setup</span>(rank, world_size):
    os.<span class="org-variable-name">environ</span>[<span class="org-string">"MASTER_ADDR"</span>] <span class="org-operator">=</span> <span class="org-string">"localhost"</span>
    os.<span class="org-variable-name">environ</span>[<span class="org-string">"MASTER_PORT"</span>] <span class="org-operator">=</span> <span class="org-string">"12345"</span>
    init_process_group(
        backend<span class="org-operator">=</span><span class="org-string">"nccl"</span>,
        rank<span class="org-operator">=</span>rank,
        world_size<span class="org-operator">=</span>world_size
    )
    torch.cuda.set_device(rank)
<span class="org-keyword">def</span> <span class="org-function-name">prepare_dataset</span>():
    ...
    <span class="org-variable-name">train_loader</span> <span class="org-operator">=</span> DataLoader(
        dataset<span class="org-operator">=</span>train_ds,
        batch_size<span class="org-operator">=</span>2,
        shuffle<span class="org-operator">=</span><span class="org-constant">False</span>,
        pin_memory<span class="org-operator">=</span><span class="org-constant">True</span>,
        drop_last<span class="org-operator">=</span><span class="org-constant">True</span>,
        <span class="org-comment-delimiter"># </span><span class="org-comment">this ensures each GPU receives different data subsample
</span>        sampler<span class="org-operator">=</span>DistributedSampler(train_ds) 
    )    
    <span class="org-keyword">return</span> train_loader, test_loader
<span class="org-keyword">def</span> <span class="org-function-name">main</span>(rank, world_size, num_epochs):      
    ddp_setup(rank, world_size)
    <span class="org-variable-name">train_loader</span>, <span class="org-variable-name">test_loader</span> <span class="org-operator">=</span> prepare_dataset()
    <span class="org-variable-name">model</span> <span class="org-operator">=</span> NeuralNetwork(num_inputs<span class="org-operator">=</span>2, num_outputs<span class="org-operator">=</span>2)
    model.to(rank)
    <span class="org-variable-name">optimizer</span> <span class="org-operator">=</span> torch.optim.SGD(model.parameters(), lr<span class="org-operator">=</span>0.5)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Wrap the model in DDP to enable gradient synchronization
</span>    <span class="org-variable-name">model</span> <span class="org-operator">=</span> DDP(model, device_ids<span class="org-operator">=</span>[rank])
    <span class="org-keyword">for</span> epoch <span class="org-keyword">in</span> <span class="org-builtin">range</span>(num_epochs):
    <span class="org-keyword">for</span> features, labels <span class="org-keyword">in</span> train_loader:
            <span class="org-variable-name">features</span>, <span class="org-variable-name">labels</span> <span class="org-operator">=</span> features.to(rank), labels.to(rank) 
            ...
            <span class="org-builtin">print</span>(f<span class="org-string">"[GPU</span>{rank}<span class="org-string">] Epoch: </span>{epoch<span class="org-operator">+</span>1:03d}<span class="org-string">/</span>{num_epochs:03d}<span class="org-string">"</span>
                  f<span class="org-string">" | Batchsize </span>{labels.shape[0]:03d}<span class="org-string">"</span>
                  f<span class="org-string">" | Train/Val Loss: </span>{loss:.2f}<span class="org-string">"</span>)
    model.<span class="org-builtin">eval</span>()
    <span class="org-variable-name">train_acc</span> <span class="org-operator">=</span> compute_accuracy(model, train_loader, device<span class="org-operator">=</span>rank)
    <span class="org-builtin">print</span>(f<span class="org-string">"[GPU</span>{rank}<span class="org-string">] Training accuracy"</span>, train_acc)
    <span class="org-variable-name">test_acc</span> <span class="org-operator">=</span> compute_accuracy(model, test_loader, device<span class="org-operator">=</span>rank)
    <span class="org-builtin">print</span>(f<span class="org-string">"[GPU</span>{rank}<span class="org-string">] Test accuracy"</span>, test_acc)
    <span class="org-comment-delimiter"># </span><span class="org-comment">exit distributed training, free up resources
</span>    destroy_process_group()                   

<span class="org-keyword">if</span> <span class="org-builtin">__name__</span> <span class="org-operator">==</span> <span class="org-string">"__main__"</span>:
    <span class="org-builtin">print</span>(<span class="org-string">"Number of GPUs available:"</span>, torch.cuda.device_count())
    torch.manual_seed(123)
    <span class="org-variable-name">num_epochs</span> <span class="org-operator">=</span> 3
    <span class="org-variable-name">world_size</span> <span class="org-operator">=</span> torch.cuda.device_count()
    mp.spawn(main, args<span class="org-operator">=</span>(world_size, num_epochs), nprocs<span class="org-operator">=</span>world_size)
</pre>
</div>

<p>
If you only want to use some GPUs, set the <code>CUDA_VISIBLE_DEVICES</code> environment variable.
</p>

<pre class="example">
CUDA_VISIBLE_DIVICES=0,2 python training_script.py
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2024-03-31 Sun 00:00</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.3 (<a href="https://orgmode.org">Org</a> mode 9.6.15)</p>
</div>
</body>
</html>
