<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Asynchronous Instructor</title>
<meta name="generator" content="Org mode">
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
<link rel="stylesheet" type="text/css" href="/orgstyle.css"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
<link rel="icon" href="favicon.ico" type="image/x-icon">
<link rel="me" href="https://emacs.ch/@dliden">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<hr style="border-top: 1px solid black;">
<div class='topnav' style='display: flex; justify-content: space-between; align-items: center;'>
  <a href="/index.html"><h2 style='margin-top: 0; margin-bottom: 0; margin-left:0px;'>Daniel Liden</h2></a>
  <div>
    <a href='/archive.html' style='font-weight:bold; font-style:italic;'>Blog</a> / 
    <a href='/about.html' style='font-weight:bold; font-style:italic;'>About Me</a> /
    <a href='/photos.html' style='font-weight:bold; font-style:italic;'>Photos</a> /
    <a href='/fine-tuning/' style='font-weight:bold; font-style:italic;'>LLM Fine Tuning</a> /
    <a href='/notes.html' style='font-weight:bold; font-style:italic;'>Notes</a> /
    <a href='/rss.xml'>
      <img src='/rss.png' style='height: 1em;'>
    </a>
  </div>
</div>
<hr style="border-top: 1px solid black;">
</div>
<div id="content">
<header>
<h1 class="title">Asynchronous Instructor</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org336e22c">Asynchronous usage pattern for Instructor</a>
<ul>
<li><a href="#orgc1c6e6a">Setup</a></li>
<li><a href="#org2231843">Iterate throught the objects</a></li>
</ul>
</li>
<li><a href="#orgf161cd8">Related Notes</a></li>
</ul>
</div>
</nav>
<div id="outline-container-org336e22c" class="outline-2">
<h2 id="org336e22c">Asynchronous usage pattern for Instructor</h2>
<div class="outline-text-2" id="text-org336e22c">
<div class="preview">
<p>
In this example, I was extracting a list of topics from a list of 1000 JSON objects loaded as a list of Python dicts.
</p>

<p>
I used the Anthropic Haiku model.
</p>

<p>
Using the instructor library with the asynchronous Anthropic client makes it much faster to make a large number of calls to the Anthropic API fairly quickly. 
</p>

</div>
<p>
(is there a batch option instead, and does it work with instructor?)
</p>
</div>

<div id="outline-container-orgc1c6e6a" class="outline-3">
<h3 id="orgc1c6e6a">Setup</h3>
<div class="outline-text-3" id="text-orgc1c6e6a">
<p>
First, we set up the Anthropic async client with Instructor. We also set up the Pydantic schema we'll be using for structured extraction.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> instructor
<span class="org-keyword">from</span> anthropic <span class="org-keyword">import</span> Anthropic, AsyncAnthropic
<span class="org-keyword">from</span> pydantic <span class="org-keyword">import</span> BaseModel
<span class="org-keyword">from</span> dotenv <span class="org-keyword">import</span> load_dotenv
<span class="org-keyword">from</span> pydantic <span class="org-keyword">import</span> BaseModel, Field


<span class="org-comment-delimiter"># </span><span class="org-comment">I had ANTHROPIC_API_KEY in a .env file</span>
load_dotenv()

<span class="org-comment-delimiter"># </span><span class="org-comment">set up the async client</span>
<span class="org-variable-name">aclient</span> = instructor.from_anthropic(AsyncAnthropic())

<span class="org-comment-delimiter"># </span><span class="org-comment">set up pydantic schema</span>
<span class="org-keyword">class</span> <span class="org-type">Topics</span>(BaseModel):
    candidates: <span class="org-builtin">list</span> = Field(
        description=(
            <span class="org-string">"List of topics that might be considered among the main topics of the talk."</span>
            <span class="org-string">" Should include (1) high level categories like 'data science' or 'ai'; (2)"</span>
            <span class="org-string">" key technologies/tools like 'spark' or 'LLMs', and (3) subtopics like"</span>
            <span class="org-string">" 'structured streaaming' or 'retrieval-augmented generation'"</span>
        )
    )
    topics: <span class="org-builtin">list</span> = Field(
        description=<span class="org-string">"List of the top main topics of the talk, from the list of candidates. Select at least one but no more than three main topics."</span>
    )
</pre>
</div>
</div>
</div>
<div id="outline-container-org2231843" class="outline-3">
<h3 id="org2231843">Iterate throught the objects</h3>
<div class="outline-text-3" id="text-org2231843">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> asyncio
<span class="org-keyword">import</span> time
<span class="org-keyword">from</span> typing <span class="org-keyword">import</span> List
<span class="org-keyword">import</span> anthropic
<span class="org-keyword">from</span> tqdm <span class="org-keyword">import</span> tqdm

<span class="org-comment-delimiter"># </span><span class="org-comment">Create a semaphore with a limit of 10 concurrent tasks</span>
<span class="org-variable-name">sem</span> = asyncio.Semaphore(10)

topics_list: <span class="org-variable-name">List</span>[<span class="org-builtin">str</span>] = []
<span class="org-variable-name">new_event_data</span> = event_data.copy()

<span class="org-keyword">async def</span> <span class="org-function-name">process_event</span>(event: <span class="org-builtin">dict</span>, sem: asyncio.Semaphore, progress_bar: tqdm) -&gt; <span class="org-constant">None</span>:
    <span class="org-variable-name">retries</span> = 3
    <span class="org-variable-name">delay</span> = 1  <span class="org-comment-delimiter"># </span><span class="org-comment">Initial delay in seconds</span>

    <span class="org-keyword">while</span> retries &gt; 0:
        <span class="org-keyword">try</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Acquire the semaphore to limit concurrency</span>
            <span class="org-keyword">async with</span> sem:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Make an asynchronous API call to create a message</span>
                <span class="org-variable-name">resp</span> = <span class="org-keyword">await</span> aclient.messages.create(
                    model=<span class="org-string">"claude-3-haiku-20240307"</span>,
                    max_tokens=1024,
                    messages=[
                        {
                            <span class="org-string">"role"</span>: <span class="org-string">"user"</span>,
                            <span class="org-string">"content"</span>: event[<span class="org-string">'abstract'</span>],
                        }
                    ],
                    response_model=Topics,
                )

                <span class="org-comment-delimiter"># </span><span class="org-comment">Store the topics in the event dictionary</span>
                <span class="org-variable-name">event</span>[<span class="org-string">'topics'</span>] = resp.topics
                topics_list.extend(resp.topics)
                progress_bar.update(1)
                <span class="org-keyword">return</span>
        <span class="org-keyword">except</span> <span class="org-type">Exception</span> <span class="org-keyword">as</span> e:
            <span class="org-keyword">if</span> <span class="org-builtin">isinstance</span>(e, anthropic._exceptions.RateLimitError):
                <span class="org-comment-delimiter"># </span><span class="org-comment">Handle rate limit error</span>
                <span class="org-variable-name">retries</span> -= 1
                <span class="org-keyword">if</span> retries &gt; 0:
                    <span class="org-keyword">print</span>(f<span class="org-string">"Rate limit reached, retrying in {delay} seconds..."</span>)
                    <span class="org-keyword">await</span> asyncio.sleep(delay)
                    <span class="org-variable-name">delay</span> *= 2  <span class="org-comment-delimiter"># </span><span class="org-comment">Exponential backoff</span>
                <span class="org-keyword">else</span>:
                    <span class="org-keyword">print</span>(<span class="org-string">"Maximum retries reached, skipping event."</span>)
            <span class="org-keyword">else</span>:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Handle other errors</span>
                <span class="org-keyword">print</span>(f<span class="org-string">"Error processing event: {e}"</span>)
                <span class="org-variable-name">retries</span> -= 1
                <span class="org-keyword">if</span> retries &gt; 0:
                    <span class="org-keyword">await</span> asyncio.sleep(delay)
                    <span class="org-variable-name">delay</span> *= 2
                <span class="org-keyword">else</span>:
                    <span class="org-keyword">print</span>(<span class="org-string">"Maximum retries reached, skipping event."</span>)

<span class="org-keyword">async def</span> <span class="org-function-name">run_in_notebook</span>() -&gt; <span class="org-constant">None</span>:
    <span class="org-variable-name">tasks</span> = []
    <span class="org-keyword">with</span> tqdm(total=<span class="org-builtin">len</span>(new_event_data), unit=<span class="org-string">"event"</span>) <span class="org-keyword">as</span> progress_bar:
        <span class="org-keyword">for</span> event <span class="org-keyword">in</span> new_event_data:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Create a task for each event and add it to the tasks list</span>
            tasks.append(process_event(event, sem, progress_bar))

        <span class="org-comment-delimiter"># </span><span class="org-comment">Wait for all tasks to complete concurrently</span>
        <span class="org-keyword">await</span> asyncio.gather(*tasks)

<span class="org-comment-delimiter"># </span><span class="org-comment">Enable asyncio support in Jupyter Notebook</span>
<span class="org-keyword">import</span> nest_asyncio
nest_asyncio.<span class="org-builtin">apply</span>()

<span class="org-comment-delimiter"># </span><span class="org-comment">Run the async function in the notebook</span>
asyncio.get_event_loop().run_until_complete(run_in_notebook())
</pre>
</div>

<p>
In this code, we:
</p>
<ul class="org-ul">
<li>define a semaphor, which limits the number of concurrent tasks/concurrent API calls. This is important as the per-minute (and, unfortunately, the per-day) rate limits for Haiku are quite low.</li>
<li>Rate limit errors result in a retry with backoff. Other exceptionls also result in retries.</li>
<li><code>await asyncio.gather(*tasks)</code> waits until the tasks are all finished.</li>
<li>The <code>nest_asyncio</code> library is used to run the async methods in a notebook.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf161cd8" class="outline-2">
<h2 id="orgf161cd8">Related Notes</h2>
<div class="outline-text-2" id="text-orgf161cd8">
<ul class="org-ul">
<li><a href="20240403-dbrx-instructor.html">Use Instructor with DBRX</a></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2024-04-18 Thu 00:00</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.3)</p>
</div>
</body>
</html>
