<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Asynchronous Instructor</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
<link rel="stylesheet" type="text/css" href="/orgstyle.css"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
<link rel="icon" href="favicon.ico" type="image/x-icon">
<link rel="me" href="https://emacs.ch/@dliden">
</head>
<body>
<div id="preamble" class="status">
<hr style="border-top: 1px solid black;">
<div class='topnav' style='display: flex; justify-content: space-between; align-items: center;'>
  <a href="/index.html"><h2 style='margin-top: 0; margin-bottom: 0; margin-left:0px;'>Daniel Liden</h2></a>
  <div>
    <a href='/archive.html' style='font-weight:bold; font-style:italic;'>Blog</a> / 
    <a href='/about.html' style='font-weight:bold; font-style:italic;'>About Me</a> /
    <a href='/photos.html' style='font-weight:bold; font-style:italic;'>Photos</a> /
    <a href='/fine-tuning/' style='font-weight:bold; font-style:italic;'>LLM Fine Tuning</a> /
    <a href='/notes.html' style='font-weight:bold; font-style:italic;'>Notes</a> /
    <a href='/rss.xml'>
      <img src='/rss.png' style='height: 1em;'>
    </a>
  </div>
</div>
<hr style="border-top: 1px solid black;">
</div>
<div id="content" class="content">
<header>
<h1 class="title">Asynchronous Instructor</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgb313bb9">Asynchronous usage pattern for Instructor</a>
<ul>
<li><a href="#org3e87c44">Setup</a></li>
<li><a href="#org59d5b87">Iterate throught the objects</a></li>
</ul>
</li>
<li><a href="#orgb18b8fd">Related Notes</a></li>
</ul>
</div>
</nav>
<div id="outline-container-orgb313bb9" class="outline-2">
<h2 id="orgb313bb9">Asynchronous usage pattern for Instructor</h2>
<div class="outline-text-2" id="text-orgb313bb9">
<div class="preview" id="org9080aa3">
<p>
In this example, I was extracting a list of topics from a list of 1000 JSON objects loaded as a list of Python dicts.
</p>

<p>
I used the Anthropic Haiku model.
</p>

<p>
Using the instructor library with the asynchronous Anthropic client makes it much faster to make a large number of calls to the Anthropic API fairly quickly. 
</p>

</div>
<p>
(is there a batch option instead, and does it work with instructor?)
</p>
</div>

<div id="outline-container-org3e87c44" class="outline-3">
<h3 id="org3e87c44">Setup</h3>
<div class="outline-text-3" id="text-org3e87c44">
<p>
First, we set up the Anthropic async client with Instructor. We also set up the Pydantic schema we'll be using for structured extraction.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> instructor
<span class="org-keyword">from</span> anthropic <span class="org-keyword">import</span> Anthropic, AsyncAnthropic
<span class="org-keyword">from</span> pydantic <span class="org-keyword">import</span> BaseModel
<span class="org-keyword">from</span> dotenv <span class="org-keyword">import</span> load_dotenv
<span class="org-keyword">from</span> pydantic <span class="org-keyword">import</span> BaseModel, Field


<span class="org-comment-delimiter"># </span><span class="org-comment">I had ANTHROPIC_API_KEY in a .env file</span>
load_dotenv()

<span class="org-comment-delimiter"># </span><span class="org-comment">set up the async client</span>
<span class="org-variable-name">aclient</span> <span class="org-operator">=</span> instructor.from_anthropic(AsyncAnthropic())

<span class="org-comment-delimiter"># </span><span class="org-comment">set up pydantic schema</span>
<span class="org-keyword">class</span> <span class="org-type">Topics</span>(BaseModel):
    <span class="org-variable-name">candidates</span>: <span class="org-builtin">list</span> <span class="org-operator">=</span> Field(
        description<span class="org-operator">=</span>(
            <span class="org-string">"List of topics that might be considered among the main topics of the talk."</span>
            <span class="org-string">" Should include (1) high level categories like 'data science' or 'ai'; (2)"</span>
            <span class="org-string">" key technologies/tools like 'spark' or 'LLMs', and (3) subtopics like"</span>
            <span class="org-string">" 'structured streaaming' or 'retrieval-augmented generation'"</span>
        )
    )
    <span class="org-variable-name">topics</span>: <span class="org-builtin">list</span> <span class="org-operator">=</span> Field(
        description<span class="org-operator">=</span><span class="org-string">"List of the top main topics of the talk, from the list of candidates. Select at least one but no more than three main topics."</span>
    )
</pre>
</div>
</div>
</div>
<div id="outline-container-org59d5b87" class="outline-3">
<h3 id="org59d5b87">Iterate throught the objects</h3>
<div class="outline-text-3" id="text-org59d5b87">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> asyncio
<span class="org-keyword">import</span> time
<span class="org-keyword">from</span> typing <span class="org-keyword">import</span> List
<span class="org-keyword">import</span> anthropic
<span class="org-keyword">from</span> tqdm <span class="org-keyword">import</span> tqdm

<span class="org-comment-delimiter"># </span><span class="org-comment">Create a semaphore with a limit of 10 concurrent tasks</span>
<span class="org-variable-name">sem</span> <span class="org-operator">=</span> asyncio.Semaphore(10)

<span class="org-variable-name">topics_list</span>: List[<span class="org-builtin">str</span>] <span class="org-operator">=</span> []
<span class="org-variable-name">new_event_data</span> <span class="org-operator">=</span> event_data.copy()

<span class="org-keyword">async def</span> <span class="org-function-name">process_event</span>(event: <span class="org-builtin">dict</span>, sem: asyncio.Semaphore, progress_bar: tqdm) <span class="org-operator">-&gt;</span> <span class="org-constant">None</span>:
    <span class="org-variable-name">retries</span> <span class="org-operator">=</span> 3
    <span class="org-variable-name">delay</span> <span class="org-operator">=</span> 1  <span class="org-comment-delimiter"># </span><span class="org-comment">Initial delay in seconds</span>

    <span class="org-keyword">while</span> retries <span class="org-operator">&gt;</span> 0:
        <span class="org-keyword">try</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Acquire the semaphore to limit concurrency</span>
            <span class="org-keyword">async with</span> sem:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Make an asynchronous API call to create a message</span>
                <span class="org-variable-name">resp</span> <span class="org-operator">=</span> <span class="org-keyword">await</span> aclient.messages.create(
                    model<span class="org-operator">=</span><span class="org-string">"claude-3-haiku-20240307"</span>,
                    max_tokens<span class="org-operator">=</span>1024,
                    messages<span class="org-operator">=</span>[
                        {
                            <span class="org-string">"role"</span>: <span class="org-string">"user"</span>,
                            <span class="org-string">"content"</span>: event[<span class="org-string">'abstract'</span>],
                        }
                    ],
                    response_model<span class="org-operator">=</span>Topics,
                )

                <span class="org-comment-delimiter"># </span><span class="org-comment">Store the topics in the event dictionary</span>
                <span class="org-variable-name">event</span>[<span class="org-string">'topics'</span>] <span class="org-operator">=</span> resp.topics
                topics_list.extend(resp.topics)
                progress_bar.update(1)
                <span class="org-keyword">return</span>
        <span class="org-keyword">except</span> <span class="org-type">Exception</span> <span class="org-keyword">as</span> e:
            <span class="org-keyword">if</span> <span class="org-builtin">isinstance</span>(e, anthropic._exceptions.RateLimitError):
                <span class="org-comment-delimiter"># </span><span class="org-comment">Handle rate limit error</span>
                <span class="org-variable-name">retries</span> <span class="org-operator">-=</span> 1
                <span class="org-keyword">if</span> retries <span class="org-operator">&gt;</span> 0:
                    <span class="org-builtin">print</span>(f<span class="org-string">"Rate limit reached, retrying in </span>{delay}<span class="org-string"> seconds..."</span>)
                    <span class="org-keyword">await</span> asyncio.sleep(delay)
                    <span class="org-variable-name">delay</span> <span class="org-operator">*=</span> 2  <span class="org-comment-delimiter"># </span><span class="org-comment">Exponential backoff</span>
                <span class="org-keyword">else</span>:
                    <span class="org-builtin">print</span>(<span class="org-string">"Maximum retries reached, skipping event."</span>)
            <span class="org-keyword">else</span>:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Handle other errors</span>
                <span class="org-builtin">print</span>(f<span class="org-string">"Error processing event: </span>{e}<span class="org-string">"</span>)
                <span class="org-variable-name">retries</span> <span class="org-operator">-=</span> 1
                <span class="org-keyword">if</span> retries <span class="org-operator">&gt;</span> 0:
                    <span class="org-keyword">await</span> asyncio.sleep(delay)
                    <span class="org-variable-name">delay</span> <span class="org-operator">*=</span> 2
                <span class="org-keyword">else</span>:
                    <span class="org-builtin">print</span>(<span class="org-string">"Maximum retries reached, skipping event."</span>)

<span class="org-keyword">async def</span> <span class="org-function-name">run_in_notebook</span>() <span class="org-operator">-&gt;</span> <span class="org-constant">None</span>:
    <span class="org-variable-name">tasks</span> <span class="org-operator">=</span> []
    <span class="org-keyword">with</span> tqdm(total<span class="org-operator">=</span><span class="org-builtin">len</span>(new_event_data), unit<span class="org-operator">=</span><span class="org-string">"event"</span>) <span class="org-keyword">as</span> progress_bar:
        <span class="org-keyword">for</span> event <span class="org-keyword">in</span> new_event_data:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Create a task for each event and add it to the tasks list</span>
            tasks.append(process_event(event, sem, progress_bar))

        <span class="org-comment-delimiter"># </span><span class="org-comment">Wait for all tasks to complete concurrently</span>
        <span class="org-keyword">await</span> asyncio.gather(<span class="org-operator">*</span>tasks)

<span class="org-comment-delimiter"># </span><span class="org-comment">Enable asyncio support in Jupyter Notebook</span>
<span class="org-keyword">import</span> nest_asyncio
nest_asyncio.<span class="org-builtin">apply</span>()

<span class="org-comment-delimiter"># </span><span class="org-comment">Run the async function in the notebook</span>
asyncio.get_event_loop().run_until_complete(run_in_notebook())
</pre>
</div>

<p>
In this code, we:
</p>
<ul class="org-ul">
<li>define a semaphor, which limits the number of concurrent tasks/concurrent API calls. This is important as the per-minute (and, unfortunately, the per-day) rate limits for Haiku are quite low.</li>
<li>Rate limit errors result in a retry with backoff. Other exceptionls also result in retries.</li>
<li><code>await asyncio.gather(*tasks)</code> waits until the tasks are all finished.</li>
<li>The <code>nest_asyncio</code> library is used to run the async methods in a notebook.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb18b8fd" class="outline-2">
<h2 id="orgb18b8fd">Related Notes</h2>
<div class="outline-text-2" id="text-orgb18b8fd">
<ul class="org-ul">
<li><a href="20240403-dbrx-instructor.html">Use Instructor with DBRX</a></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2024-04-18 Thu 00:00</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.3 (<a href="https://orgmode.org">Org</a> mode 9.6.15)</p>
</div>
</body>
</html>
